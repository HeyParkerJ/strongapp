(ns strongapp.core
  (:require
   [clojure-csv.core :refer [parse-csv]]
   [strongapp.database :refer [groom-data insert]]
   [clojure.string :as s]))

;; https://stackoverflow.com/a/13646484
(defn open-file
  "Attempts to open a file and complains if the file is not present."

  [file-name]
  (let [file-data (try
                    (slurp file-name)
                    (catch Exception e (println (.getMessage e))))]
    file-data))

(defn ret-csv-data
  "Returns a lazy sequence generated by parse-csv.
  Uses open-file which will return a nil, if
  there is an exception in opening fnam.

  parse-csv called on non-nil file, and that
  data is returned."

  [fnam]
  (let [csv-file (open-file fnam)
        inter-csv-data (if-not (nil? csv-file)
                         (parse-csv csv-file)
                         nil)

        csv-data 
        (vec (filter #(and pos? (count %) 
                           (not (nil? (rest %)))) inter-csv-data))]

    (if-not (empty? csv-data)
      (pop csv-data)
      nil)))

(defn fetch-csv-data
  "This function accepts a csv file name, and returns parsed csv data,
     or returns nil if file is not present."

  [csv-file]
  (let [csv-data (ret-csv-data csv-file)]
    csv-data))

(defn- keywordize-
  "takes a map, converts string keys to keyword keys
   with all lowercase and dash instead of spaces"
  [m]
  (into {}
        (for [[k v] m]
          [(keyword (s/lower-case (s/replace k #" " "-"))) v])))

(defn csv-to-map
  "parses a csv to a map
   ([csv & {:as opts}])
   passes options to clojure-csv
   converts string keys to keywords
   if ':key :keyword' is pass as extra opts.
   "
  [csv & {key :key :as opts}]
  (let [opts   (vec (reduce concat (vec opts)))
        c      (apply clojure-csv.core/parse-csv csv opts)
        output (map (partial zipmap (reverse (first c))) (map reverse (rest c)))]
    (if (= key :keyword) (map keywordize- output) output)))

(defn main
  [& args]
  (println "Opening file")
  (let [results (fetch-csv-data "resources/strong.csv")]
    (println results)
    (for [d results] (println d))
    ))

(defn -main
  []
  (def data (csv-to-map (slurp "resources/strong.csv") :key :keyword))
  (def finaldata (groom-data data))
  (insert "postgresql://strongapp:foobar@localhost:5432/strongdb" finaldata)
  )

;;(defn main
 ;; []
  ;;(let [data (insert "postgresql://strongapp:foobar@localhost:5432/strongdb")]
  ;;(for [data] (print *))))
